 ----
 Persistent entity criteria API
 ----
 Vojtech Szocs
 ----
 19 July 2009
 ----

Persistent entity criteria API
  
  Construct persistent entity criteria with advanced filtering, sorting and paging capabilities and pass them to DAO methods to query for desired results.
  
Sections
  
  * {{{./entity-criteria-api.html#Overview} Overview}}
  
  * {{{./entity-criteria-api.html#Introduction} Introduction}}
  
  * {{{./entity-criteria-api.html#Persistent_entity_criteria_API_overview} Persistent entity criteria API overview}}
  
  * {{{./entity-criteria-api.html#Property_criterion_classes} Property criterion classes}}
  
  * {{{./entity-criteria-api.html#Sample_DAO_using_both_filter_value_strategies} Sample DAO using both filter value strategies}}
  
  * {{{./entity-criteria-api.html#FAQ} FAQ}}
  
  []
  
External resources
  
  * {{{http://www.hibernate.org/hib_docs/v3/api/org/hibernate/Criteria.html} Hibernate Criteria API}}
  
  []
  
* {Overview}
  
  * Project: <${df-core}>
  
  * Package reference: <<<com.anasoft.os.daofusion.criteria>>>
  
* {Introduction}
  
  Having your {{{./entity-model.html} domain model}} along with associated {{{./core-dao-classes.html} DAO classes}} implemented brings you to a question that might have arisen
  when inspecting <<<PersistentEntityDao>>> query methods: what is actually the <<<PersistentEntityCriteria>>> interface? This section explains the persistent entity criteria
  concept in detail so that you can bring the standard DAO functionality to a whole new level.
  
* {Persistent entity criteria API overview}
  
  If you look at the generic <<<AbstractHibernateEntityDao>>> implementation you will notice that it merely delegates its DAO operations to the underlying Hibernate <<<Session>>>. Things
  should be easy, right? One of the main benefits of having a standard DAO interface is the ability to define a custom criteria API that should cover 90% of the most typical use cases out there.
  This is exactly the purpose of the <<<PersistentEntityCriteria>>> interface and associated classes - to shield an average user from any Hibernate-specific implementation details allowing advanced
  users to use the underlying {{{http://www.hibernate.org/hib_docs/v3/api/org/hibernate/Criteria.html} Hibernate Criteria API}} directly if necessary at the same time. In fact, using the
  <Hibernate Criteria API> directly in your DAO implementations should be the last resort for all but the most complex cases where a custom <<<PersistentEntityCriteria>>> implementation is not possible
  (remember that even custom <<<PersistentEntityCriteria>>> implementations can be efficiently and consistently reused between multiple DAOs as opposed to the direct <Hibernate Criteria API> approach).
  
  <<<PersistentEntityCriteria>>> interface defines the general contract for persistent entity query constraints bound to the underlying Hibernate <<<Criteria>>> instance. ${df} enforces the use of
  <Hibernate Criteria API> under the hood to ensure database portability (no dynamic HQL / SQL generation involved). This makes ${df} generic and reusable across multiple database vendors (assuming
  the provided {{{https://www.hibernate.org/hib_docs/v3/api/org/hibernate/dialect/Dialect.html} dialect}} is up to date for the given database).
  
  Let's take a brief look at this interface to get a basic understanding of the criteria API concept:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-PersistentEntityCriteria.java}
  
  As you can see, there is no rocket science going on here - implementations of the <<<PersistentEntityCriteria>>> interface are merely responsible for updating the Hibernate <<<Criteria>>>
  instance according to any query constraints they define. The simplicity of this interface is intentional so that users can write their own implementations with full control over Hibernate
  <<<Criteria>>> instance processing. Note that the <<<AbstractHibernateEntityDao>>> uses this interface when constructing the Hibernate <<<Criteria>>> instance via <<<BaseHibernateDataAccessor>>>'s
  <getCriteria> method before setting any projections and requesting results via the <Hibernate Criteria API>.
  
  <<<AbstractCriterionGroup>>> represents the base class for <<<PersistentEntityCriteria>>> implementations that manage <<<PersistentEntityCriterion>>> instances to define individual query constraints.
  <<<AbstractCriterionGroup>>> defines the contract for paging criteria (<firstResult> and <maxResults>) as well as the application of such criteria to the target Hibernate <<<Criteria>>> instance
  via the <applyPagingCriteria> method. This class also provides a basic implementation of <<<PersistentEntityCriteria>>>'s <apply> method:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-AbstractCriterionGroup-ApplyMethod.java}
  
  <<<AbstractCriterionGroup>>> uses the {{{http://en.wikipedia.org/wiki/Visitor_pattern} visitor pattern}} to impose centralized <<<PersistentEntityCriterion>>> processing in terms of applying individual
  query constraints (<<<PersistentEntityCriterion>>> instances) to the target Hibernate <<<Criteria>>> instance. The <getCriterionVisitor> method is declared as abstract so that arbitrary visitor
  implementations can be used in <<<AbstractCriterionGroup>>> subclasses:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-AbstractCriterionGroup-GetCriterionVisitorMethod.java}
  
  So, what is this <<<PersistentEntityCriterion>>> interface all about? <<<PersistentEntityCriterion>>> represents an abstraction of a single query constraint that uses the visitor pattern as shown above
  for applying its query constraints into the target Hibernate <<<Criteria>>> instance:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-PersistentEntityCriterion.java}
  
  Note that you can implement this interface on your own if you want to plug in your custom criterion implementations in conjunction with an appropriate <<<AbstractCriterionGroup>>> and a corresponding
  criterion visitor.
  
  So far, this has been all too generic. The reason why we built such abstractions above the default <<<PersistentEntityCriteria>>> implementation is to make ${df} entity criteria API as flexible
  and extensible as possible. We encourage users to provide their own <<<PersistentEntityCriteria>>> implementations in special or more complex cases in favor of using <Hibernate Criteria API> directly.
  
  <<<NestedPropertyCriteria>>> is the default general purpose <<<PersistentEntityCriteria>>> implementation based on the <<<AbstractCriterionGroup>>> in conjunction with <<<NestedPropertyCriterion>>>
  instances. <<<NestedPropertyCriteria>>> implements the query constraint application logic regarding specific <<<NestedPropertyCriterion>>> subclasses via default <<<NestedPropertyCriterionVisitor>>>
  implementation (returned as the result of the <getCriterionVisitor> method):
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-NestedPropertyCriterionVisitor.java}
  
  In addition to managing <<<NestedPropertyCriterion>>> instances and providing a visitor that is able to process them, the <<<NestedPropertyCriteria>>> contains features that are common to either
  all or certain <<<NestedPropertyCriterion>>> instances:
  
  * filter object as an optional source of filter values (shared by all <<<FilterCriterion>>> instances)
  
  * use of an <<<AssociationPathRegister>>> for preprocessing root Hibernate <<<Criteria>>> regarding nested subcriteria (defined by <<<NestedPropertyCriterion>>> via the <<<AssociationPath>>>)
  
  []
  
  <<<NestedPropertyCriterion>>> supports a nested property of a persistent entity, starting at the target persistent entity as the root object and navigating through associated objects as necessary.
  In other words, <<<NestedPropertyCriterion>>> enables you to write a criterion that spans over multiple entities, reaching the desired property of the desired entity from the root object just like
  a tentacle.
  
  <<TODO: image of tentacle - root entity, associated entities, final entity/property>>
  
  <<<NestedPropertyCriterion>>> is essentially a combination of two factors:
  
  * <<<AssociationPath>>> which points to the given property of the target persistent entity
  
  * <targetPropertyName> denoting target property of the given persistent entity
  
  []
  
  In Hibernate, you would normally use the <createCriteria> method to create constraints for nested properties of the given root entity. However, you would have to manage nested <<<Criteria>>>
  instances on your own regarding their reuse across multiple criterion instances (two criterion instances can share a common association path "prefix"). This can ultimately bring you to the
  {{{http://opensource.atlassian.com/projects/hibernate/browse/HHH-879} duplicate association path}} <Hibernate Criteria API> issue which has serious implications on the way of writing complex
  queries operating with nested properties.
  
  Now this is the part when <<<AssociationPathRegister>>> kicks in. <<<AssociationPathRegister>>> is simply a map of <<<AssociationPath>>> instances and corresponding Hibernate <<<Criteria>>>
  to be reused when modifying the root <<<Criteria>>> instance. <<<NestedPropertyCriteria>>> uses this class to initialize Hibernate <<<Subcriteria>>> mappings in a safe way, avoiding the
  duplicate association path issue that might have arisen during the criterion visitor execution. <<<AssociationPathRegister>>> is essentially a thin wrapper around the given <<<Criteria>>>
  instance that gets initialized with existing <<<Subcriteria>>> mappings at construction time. It is therefore safe to create multiple <<<AssociationPathRegister>>> instances operating on
  the same <<<Criteria>>>. The best part is that you can use this class to modify <<<Criteria>>> instances in a safe way on your own as well:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-AssociationPathRegisterUsage.java}
  
  There are a few new classes mentioned in the sample code shown above:
  
  * <<<AssociationPathElement>>> - single element of an <<<AssociationPath>>> that contains the <value> corresponding with the given persistent entity property name, as well as the optional
    <joinType> which specifies the type of join to use when creating related <<<Subcriteria>>> rooted under the parent <<<Criteria>>> instance
  
  * <<<AssociationPath>>> - ordered list of association path elements which point to the given property of a persistent entity, starting at the target persistent entity as the root object
    and navigating through associated objects as necessary (note that the association path doesn't include the target property itself, it's just a path to that property)
  
  * <<<NestedPropertyJoinType>>> - enumeration of possible database join types applicable to <<<AssociationPathElement>>> instances
  
  []
  
  All of the classes listed above are immutable by design so that you can safely reuse their instances across your code.
  
* {Property criterion classes}
  
  Let's take a look at two <<<NestedPropertyCriterion>>> subclasses that are intended for direct use in conjunction with <<<NestedPropertyCriteria>>>: <<<FilterCriterion>>> and <<<SortCriterion>>>.
  
  <<<FilterCriterion>>> defines filter constraints for the given entity property via the <<<PropertyFilterCriterionProvider>>> interface. A custom <<<PropertyFilterCriterionProvider>>> implementation
  is used to construct a Hibernate <<<Criterion>>> instance regarding the filter criterion as well as deciding whether to actually use the provided <<<Criterion>>> instance:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-PropertyFilterCriterionProvider.java}
  
  There are basically two ways to pass data to the custom <<<PropertyFilterCriterionProvider>>> implementation from within the <<<FilterCriterion>>>:
  
  * by specifying <filterObjectValuePaths> - array of dot-separated logical paths pointing to values reachable from the root filter object (same concept as the <propertyPath> mentioned above)
  
  * by providing filter values directly via the <directValues> object array
  
  []
  
  Note that the <filterObjectValuePaths> will be translated into <filterObjectValues> during the criterion instance processing within the default <<<NestedPropertyCriterionVisitor>>>
  implementation. The <enabled> method (called before each <getCriterion> method invocation) can be used for disabling the <<<PropertyFilterCriterionProvider>>> implementation from actually
  being used at all - this can be helpful in certain situations, such as:
  
  * filter value inconsistency (the <<<PropertyFilterCriterionProvider>>> is unable to build the corresponding <<<Criterion>>> instance due to missing or null data)
  
  * manual filter switch (the user wants to have control over when this provider should be active)
  
  []
  
  By having full control over the Hibernate <<<Criterion>>> instance creation via the <<<PropertyFilterCriterionProvider>>> interface, the user is able to define even the most complex property
  criteria with ease without having to worry about any nested subcriteria details. For example:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-PropertyFilterCriterionProviderUsage.java}
  
  The combination of <filterObjectValuePaths> and <directValues> enables you to define your own filter value strategy - a single filter object as the source of filter values, direct
  value approach or even a combination of the two.
  
  <<<SortCriterion>>>, on the other hand, defines sort constraints for the given entity property using two boolean parameters: <sortAscending> and <ignoreCase> (the latter works only for
  string-based properties). Note that the <<<SortCriterion>>> is always "enabled" when present within the <<<NestedPropertyCriteria>>>.
  
* {Sample DAO using both filter value strategies}
  
  The following code shows an extended version of the sample DAO from the {{{./core-dao-classes.html} previous section}}, using filter object together with the direct value approach
  to employ custom constraints on the <<<Order>>> entity:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/entity-criteria-api-SampleDaoUsingBothFilterValueStrategies.java}
  
  In this example, <<<QueryDefinition>>> represents a generic persistent entity query that supports filtering, sorting and paging capabilities of the underlying <<<NestedPropertyCriteria>>>
  implementation (notice that a single sort property is supported in this case though). The user is responsible for initializing the <filterObject> as well as its associated objects properly
  according to filter constraints bound to it before passing it to the <getOrders> method as part of the <<<QueryDefinition>>>. By modifying the state of the <filterObject>, the user is able
  to change the actual filter criteria that use filter object values without touching the underlying <<<NestedPropertyCriteria>>> in any way. This is essentially the main purpose of the filter
  object approach - to separate the criteria definition from the actual filter values accessible from a single object.
  
  One important thing to note here is that our sample DAO implementation is stateless, which is generally recommended for most cases. Stateless DAOs can be efficiently managed as
  {{{http://en.wikipedia.org/wiki/Singleton_pattern} singleton}} beans (e.g. within a Spring context) and injected into service classes without having to worry about
  {{{http://en.wikipedia.org/wiki/Thread-safety} thread safety}} issues. This is especially true for web applications where each request is bound to a dedicated worker thread.
  
  In general, the filter object approach is especially useful in applications where GUI changes can be seamlessly propagated to the server, modifying the filter object instance of the given
  server-side component (for example, a {{{http://java.sun.com/javaee/javaserverfaces/} Java Server Faces}} managed bean bound to web page using server-side AJAX callback handlers). Note that
  the abstract <<<PropertyFilterCriterionProvider>>> implementations in the above example ensure that corresponding <<<FilterCriterion>>> instances won't be processed unless the filter data is
  consistent (the filter criteria won't be applied unless the filter object or <minOrderItemCount> contain proper values).
  
  In certain scenarios where the client side and server side connect more loosely to each other using a custom communication mechanism (e.g. <GWT RPC> for {{{http://code.google.com/webtoolkit/} Google Web Toolkit}}
  or {{{http://en.wikipedia.org/wiki/Action_Message_Format} AMF}} for {{{http://www.adobe.com/products/flex/} Flex}}), direct filter object changes are not possible since the client side typically
  uses some local data model bound to the GUI and calls remote services when necessary. Although it is possible to change the filter object accordingly using some server-side request processor,
  it is much more convenient to use the {{{./cto-pattern.html} criteria transfer object pattern}} in this situation.
  
* {FAQ}
  
  We recommend browsing through the {{{./reference-faq.html} Reference Documentation FAQ}} for detailed information on related issues.
