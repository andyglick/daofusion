 ----
 Bitemporal pattern
 ----
 Igor Mihalik;
 Vojtech Szocs;
 meta-description=Add temporal aspects to your business domain, tracking persistent entities in two distinct timelines denoting the validity of facts and your knowledge of such facts throughout the time.
 ----
 9 September 2009
 ----

Bitemporal pattern
  
  Add temporal aspects to your business domain, tracking persistent entities in two distinct timelines denoting the validity of facts and your knowledge of such facts throughout the time.
  
Sections
  
  * {{{./bitemporal-pattern.html#Overview} Overview}}
  
  * {{{./bitemporal-pattern.html#Introduction} Introduction}}
  
  * {{{./bitemporal-pattern.html#Bitemporal_class_overview} Bitemporal class overview}}
  
  * {{{./bitemporal-pattern.html#Bitemporal_entity_example} Bitemporal entity example}}
  
  []
  
Related tech notes
  
  * {{{../technote/temporal-aspects.html} Temporal Aspects in Domain Models}}
  
* {Overview}
  
  * Project: <${df-core}>
  
  * Package reference: <<<com.anasoft.os.daofusion.bitemporal>>>
  
* {Introduction}
  
  Many application domains are inherently temporal, yet only a few people consider using appropriate {{{http://martinfowler.com/eaaDev/timeNarrative.html} temporal patterns}} at the very beginning of business
  requirement analysis. This is partly due to the fact that it is natural for us to think in a non-temporal and static way. We build data-driven applications without the possibility to track necessary data changes
  throughout the time. It usually happens during later project phases that people realize they need a way to track data in terms of its validity (data valid at the given point in time) or relevance (our knowledge
  of such data at the given point in time). Developers start adding time intervals to persistent entities on a per-situation basis, new date columns start to appear in the database schema and things usually get messed
  up in general.
  
  Bitemporal pattern offers an elegant and sophisticated way of dealing with most temporal issues. The bitemporal pattern implementation offered by ${df} builds upon a {{{https://svn.ervacon.com/public/projects/bitemporal/trunk/} bitemporal framework}}
  created by Erwin Vervaet and Christophe Vanfleteren. You can learn more about this framework from their presentation {{{https://svn.ervacon.com/public/projects/bitemporal/trunk/doc/Temporal%20Issues%20in%20a%20Rich%20Domain%20Model%20-%20TSE%202007.pdf} Temporal Issues in a Rich Domain Model}}.
  We have extended the original implementation in terms of:
  
  * class parametrization (type safety)
  
  * using annotations instead of classic Hibernate mapping files (<<<*.hbm.xml>>>)
  
  * integration with existing {{{./entity-model.html} persistent entity model}}
  
  * extending the built-in thread-local reference time using the {{{http://en.wikipedia.org/wiki/Strategy_pattern} strategy pattern}}
  
  []
  
  The rest of this document assumes you are familiar with {{{../technote/temporal-aspects.html} temporal concepts}} and their implications on implementing them in a non-temporal relational database.
  
* {Bitemporal class overview}
  
  <<<Bitemporal>>> interface representing a bitemporally tracked value is the key concept to grasp. <<<Bitemporal>>> essentially defines a {{{http://martinfowler.com/eaaDev/TemporalObject.html} temporal object}}
  whose value is tracked in two distinct (and completely orthogonal) time dimensions: validity time and record time.
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-Bitemporal.java}
  
  Note that the <<<Bitemporal>>> interface abstracts from a concrete way of storing or retrieving the actual value. In addition to time intervals, there are some additional methods representing basic
  bitemporal operations:
  
  * ending the bitemporal object in terms of its record interval (typically used when an object is superseded by another object)
  
  * creating a copy of the current bitemporal object using a new validity interval (and the recording interval as well) but retaining the original value
  
  []
  
  Since <<<Bitemporal>>> combines two timelines and associated operations together, it is well suited to be managed in a trace (collection). Additive, retroactive and proactive changes regarding the value
  and/or validity interval can be subsequently implemented using methods provided by the <<<Bitemporal>>> interface. The record interval cannot be modified explicitly by the user and always depends on the
  current value of "now" (reference time or current local time).
  
  <<<BitemporalWrapper>>> is the default <<<Bitemporal>>> implementation intended for use with JPA / Hibernate. <<<BitemporalWrapper>>> is a <<<@MappedSuperclass>>> which decorates the value with bitemporal
  information in terms of two custom entity properties (<validityInterval> and <recordInterval>). These two properties are essentially persisted by Hibernate using custom <<<CompositeUserType>>> implementations:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-BitemporalWrapper-CustomIntervalProperties.java}
  
  As you can see, each interval gets mapped to two date columns in the database table (<*From> and <*To>). Bitemporal classes use {{{http://joda-time.sourceforge.net/} Joda Time}} (e.g. <<<Interval>>>
  and <<<DateTime>>>) which proves to be better than the standard Java date/time support.
  
  <<<BitemporalWrapper>>> allows us to bitemporally track existing value classes, for instance strings, by wrapping them along with appropriate time information. <<<BitemporalWrapper>>> contains two abstract
  methods for managing the actual value (<getValue> and <setValue>) - these should be implemented by your <<<BitemporalWrapper>>> subclasses corresponding to your business domain. Due to the nature of bitemporality,
  the wrapped value should be immutable. The value itself will never change, instead new entries will be added to the trace to represent changes of the value. The <<<BitemporalWrapper>>> itself, however,
  is not immutable - its record interval can be ended via the <end> method.
  
  Having bitemporal objects is nice, but there needs to be a class responsible for querying and manipulating such objects in a way that resembles a "trace" (a continuous flow of bitemporal object changes throughout
  both timelines). This is exactly the purpose of <<<BitemporalTrace>>>. <<<BitemporalTrace>>> is simply a collection of <<<Bitemporal>>> objects (raw data) and associated trace operations. Such trace operations
  include:
  
  * adding a bitemporal object to the trace, manipulating the trace as necessary
  
  This is essentially the basic bitemporal data manipulation operation.
  
  * getting a bitemporal object valid on the given date (<validOn>) as known on specified date (<knownOn>)
  
  This is a query for bitemporal objects across both timelines.
  
  * getting the <history> of the tracked value, as known on specified time (the history informs you about how the valid value changed over time)
  
  This is a query for bitemporal objects across the record timeline.
  
  * getting the <evolution> of the tracked value for a specified validity date (the evolution informs you about how knowledge about the value valid at a certain date evolved)
  
  This is a query for bitemporal objects across the validity timeline.
  
  []
  
  <<<BitemporalTrace>>> is a low-level API for bitemporal data tracking and manipulation. <<<BitemporalProperty>>> representing a bitemporally tracked property of a class wraps the <<<BitemporalTrace>>>
  along the property <<<ValueAccessor>>> to give users a high-level and convenient API. This is somewhat similar to the {{{http://martinfowler.com/eaaDev/TemporalProperty.html} temporal property}} pattern,
  except that we are dealing with two time dimensions. <<<BitemporalProperty>>> declares two class parameters: the actual value type (e.g. <<<String>>>) and the <<<Bitemporal>>> object implementation that
  wraps the given value type. <<<BitemporalProperty>>> offers convenience methods for retrieving the value valid on specified date as known on given date, falling back to default date ("now") as necessary.
  There are methods for accessing the value itself or the <<<Bitemporal>>> object holding the time information (along with the value). Furthermore, a <<<BitemporalProperty>>> allows you to get the history
  or evolution of the given value, <set> or <end> the value itself for the given validity date and find out whether there is a value for the given date (<hasValue>).
  
  <<<BitemporalProperty>>> uses the <<<ValueAccessor>>> interface to extract actual values from <<<Bitemporal>>> objects:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-ValueAccessor.java}
  
  This makes it possible to implement methods that return actual values corresponding to matching bitemporal objects (<extractValue> method), as well as adding new values to the trace (<wrapValue> method).
  
  Since the <<<BitemporalWrapper>>> already defines the value type and relevant accessors, there is an adapter to the <<<ValueAccessor>>> interface that can be used in case of JPA / Hibernate (which is
  definitely the stuff we're interested in): <<<WrappedValueAccessor>>>. This abstract class implements the <extractValue> method for you and provides a static <create> method for constructing dynamic
  instances using Java reflection.
  
  Similar to <<<WrappedValueAccessor>>>, there is a convenience <<<BitemporalProperty>>> subclass intended for use with JPA / Hibernate - <<<WrappedBitemporalProperty>>>. This class just narrows
  the type of bitemporal object to <<<BitemporalWrapper>>> and works in pair with <<<WrappedValueAccessor>>>.
  
  Last but not least, there is a utility class dedicated for dealing with time in general: <<<TimeUtils>>>. You can use this class to:
  
  * set, get and clear out the reference time
  
  * retrieve current reference or current local time
  
  * create <<<Interval>>> and <<<DateTime>>> instances, possibly using the reference time
  
  []
  
  Note that the reference time always falls back to the current local time if it has not been set previously.
  
  <<<TimeUtils>>> abstracts from the way the reference time is physically managed using the <<<ReferenceTimeProvider>>> strategy interface. A <<<ReferenceTimeProvider>>> implementation is responsible
  for managing the reference time in terms of getting, setting and clearing out (un-setting) its value:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-ReferenceTimeProvider.java}
  
  <<<TimeUtils>>> is essentially a static {{{http://en.wikipedia.org/wiki/Facade_pattern} facade}} to a concrete <<<ReferenceTimeProvider>>> implementation, which is set to <<<ThreadLocalReferenceProvider>>>
  by default. You can override this default provider by calling the static <setReferenceProvider> method upon application startup.
  
* {Bitemporal entity example}
  
  Let's say you want to have a persistent entity tracked bitemporally within your domain model. Such persistent entity should be user-immutable and contained as a property of a parent non-temporal entity
  (wrapper entity). Being user-immutable means that the state of an entity cannot be changed by the user after its construction (this is enforced by using <protected> setters). This is due to the fact that
  Hibernate invokes the default no-argument constructor and corresponding fields or setters reflectively when creating entity instances. A good practice is to use {{{http://www.javapractices.com/topic/TopicAction.do?Id=15} defensive copying}}
  when dealing with standard mutable classes, for instance <<<java.util.Date>>>.
  
  Given the knowledge above, our sample persistent entity we wish to track bitemporally might look like this:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-SampleBitemporalPersistentEntity.java}
  
  We also need a parent wrapper entity that holds time information along the actual value:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-SampleBitemporalPersistentEntityWrapper.java}
  
  We can now define a root persistent entity that holds a reference to the corresponding bitemporal trace (denoted by the <Collection> interface as known to Hibernate):
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-SampleBitemporalPersistentEntityRoot.java}
  
  How cool is that? The <getOrders> method can be used to access and modify bitemporal trace of <<<BitemporalOrder>>> instances via <<<WrappedBitemporalProperty>>>, leaving Hibernate happy in the knowledge
  that <orders> is a "simple" persistent collection. Following code shows sample usage of the <getOrders> method:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-WrappedBitemporalPropertyUsage.java}
  
  To sum it up:
  
  * <<<Order>>> is the value to be tracked bitemporally
  
  * <<<BitemporalOrder>>> is the temporal object (value plus additional time information)
  
  * <<<Customer>>> is the root entity holding a trace of temporal objects
  
  []
  
  For primitive object types (e.g. <<<Long>>> or <<<String>>>), the wrapper entity could look like this:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/bitemporal-pattern-SampleBitemporalPrimitiveValueWrapper.java}
  
  The root entity (e.g. <<<Person>>>) could then declare a property of type <<<Collection\<BitemporalLong\>>>> to track the <<<Long>>> value in both time dimensions.
  
%{html-template-snippet|missingValuesToEmptyStrings=1|htmlFile=src/site/snippet/html/google-friend-connect-comments-gadget.html|paramFile=src/site/snippet/html/google-friend-connect-comments-gadget.properties}
  
