 ----
 ${df} overview
 ----
 Vojtech Szocs;
 meta-description=Brief overview of what ${df} is and what features it offers from a high-level perspective.
 ----
 10 September 2009
 ----

${df} overview
  
  Building, testing and maintaining {{{http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html} Data Access Object}} layers in applications can be basically
  done in two ways:
  
  * let the developers build up all the boilerplate code and configuration (which is, hopefully, easy to maintain in the long run) along with proper integration tests
  
  * use a comprehensive and well-tested library that handles all these tasks for you, saving you time and resources and letting you focus on the actual business logic
  
  []
  
* Choose your way
  
  ${df} aims to help Java developers build their server-side DAO layers with ease, doing most of the usual heavy lifting and providing support for common DAO-related tasks and patterns.
  
[images/overview.png] ${df} overview
  
  ${df} introduces conventions and best practices into DAO layer development in terms of a consistent and extensible {{{./reference/entity-model.html} persistent entity model}}
  and standard {{{./reference/core-dao-classes.html} DAO interfaces / abstract implementations}} which already provide most of the usual DAO functionality. ${df} defines a generic
  and extensible {{{./reference/entity-criteria-api.html} entity criteria API}} that covers most typical use cases while taking care of {{{http://www.hibernate.org/} Hibernate}}
  specific issues at the same time.
  
  ${df} supports applications with loose coupling between the client and server via the {{{./reference/cto-pattern.html} criteria transfer object pattern}}, which helps when building
  complex client-side data components that use filtering, sorting and paging functionality. The {{{./reference/bitemporal-pattern.html} bitemporal pattern}}, on the other hand,
  helps to add {{{./technote/temporal-aspects.html} temporal aspects}} to domain models in order to track data in time. 
  
  Last but not least, ${df} provides an out-of-the-box {{{./reference/integration-tests.html} integration test support}} that ensures proper test coverage of core DAO functionality
  and enables you to write your own custom integration tests for the chosen database at the same time.
  
* How it all started
  
  ${df} results from an effort to unify the concept of a DAO layer across projects based on Java platform. ${df} evolved from a simple DAO library to its present state thanks
  to people who realized the benefits of such solution in long-term horizon. Should we decide to stick with plain-old JPA / Hibernate together with some simple DAO abstractions,
  we would most probably end up with code that is hard to change and test later, bound to Hibernate specifics and quirks, not even mentioning that other Java projects did the same
  thing while repeating same old patterns.
  
  For developers, adopting ${df} might be an overhead since they can go straight with JPA / Hibernate in their applications anyway. However, <in the long run>, it's a different story.
  
* Open source - why not?
  
  The fact that ${df} went {{{http://en.wikipedia.org/wiki/Open_source_software} open source}} after its initial release was a natural step in its evolution. After all, what's the real
  benefit of having such library hidden inside a company with a couple of people responsible for its maintenance and further development?
  
  <Open source projects involve many people collaborating together to build a software that is useful to each and every community member>, and that's the value ${df} aims to achieve.
  
%{html-template-snippet|missingValuesToEmptyStrings=1|htmlFile=src/site/snippet/html/google-friend-connect-comments-gadget.html|paramFile=src/site/snippet/html/google-friend-connect-comments-gadget.properties}
  
